import { __spread, __generator } from 'tslib';
import compare from 'just-compare';

/* tslint:disable:no-non-null-assertion */
var ListNode = /** @class */ (function () {
    function ListNode(value) {
        this.value = value;
    }
    return ListNode;
}());
var LinkedList = /** @class */ (function () {
    function LinkedList() {
        this.size = 0;
    }
    Object.defineProperty(LinkedList.prototype, "head", {
        get: function () {
            return this.first;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinkedList.prototype, "tail", {
        get: function () {
            return this.last;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinkedList.prototype, "length", {
        get: function () {
            return this.size;
        },
        enumerable: true,
        configurable: true
    });
    LinkedList.prototype.attach = function (value, previousNode, nextNode) {
        if (!previousNode)
            return this.addHead(value);
        if (!nextNode)
            return this.addTail(value);
        var node = new ListNode(value);
        node.previous = previousNode;
        previousNode.next = node;
        node.next = nextNode;
        nextNode.previous = node;
        this.size++;
        return node;
    };
    LinkedList.prototype.attachMany = function (values, previousNode, nextNode) {
        if (!values.length)
            return [];
        if (!previousNode)
            return this.addManyHead(values);
        if (!nextNode)
            return this.addManyTail(values);
        var list = new LinkedList();
        list.addManyTail(values);
        list.first.previous = previousNode;
        previousNode.next = list.first;
        list.last.next = nextNode;
        nextNode.previous = list.last;
        this.size += values.length;
        return list.toNodeArray();
    };
    LinkedList.prototype.detach = function (node) {
        if (!node.previous)
            return this.dropHead();
        if (!node.next)
            return this.dropTail();
        node.previous.next = node.next;
        node.next.previous = node.previous;
        this.size--;
        return node;
    };
    LinkedList.prototype.add = function (value) {
        var _this = this;
        return {
            after: function () {
                var _a;
                var params = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    params[_i] = arguments[_i];
                }
                return (_a = _this.addAfter).call.apply(_a, __spread([_this, value], params));
            },
            before: function () {
                var _a;
                var params = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    params[_i] = arguments[_i];
                }
                return (_a = _this.addBefore).call.apply(_a, __spread([_this, value], params));
            },
            byIndex: function (position) { return _this.addByIndex(value, position); },
            head: function () { return _this.addHead(value); },
            tail: function () { return _this.addTail(value); },
        };
    };
    LinkedList.prototype.addMany = function (values) {
        var _this = this;
        return {
            after: function () {
                var _a;
                var params = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    params[_i] = arguments[_i];
                }
                return (_a = _this.addManyAfter).call.apply(_a, __spread([_this, values], params));
            },
            before: function () {
                var _a;
                var params = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    params[_i] = arguments[_i];
                }
                return (_a = _this.addManyBefore).call.apply(_a, __spread([_this, values], params));
            },
            byIndex: function (position) { return _this.addManyByIndex(values, position); },
            head: function () { return _this.addManyHead(values); },
            tail: function () { return _this.addManyTail(values); },
        };
    };
    LinkedList.prototype.addAfter = function (value, previousValue, compareFn) {
        if (compareFn === void 0) { compareFn = compare; }
        var previous = this.find(function (node) { return compareFn(node.value, previousValue); });
        return previous ? this.attach(value, previous, previous.next) : this.addTail(value);
    };
    LinkedList.prototype.addBefore = function (value, nextValue, compareFn) {
        if (compareFn === void 0) { compareFn = compare; }
        var next = this.find(function (node) { return compareFn(node.value, nextValue); });
        return next ? this.attach(value, next.previous, next) : this.addHead(value);
    };
    LinkedList.prototype.addByIndex = function (value, position) {
        if (position < 0)
            position += this.size;
        else if (position >= this.size)
            return this.addTail(value);
        if (position <= 0)
            return this.addHead(value);
        var next = this.get(position);
        return this.attach(value, next.previous, next);
    };
    LinkedList.prototype.addHead = function (value) {
        var node = new ListNode(value);
        node.next = this.first;
        if (this.first)
            this.first.previous = node;
        else
            this.last = node;
        this.first = node;
        this.size++;
        return node;
    };
    LinkedList.prototype.addTail = function (value) {
        var node = new ListNode(value);
        if (this.first) {
            node.previous = this.last;
            this.last.next = node;
            this.last = node;
        }
        else {
            this.first = node;
            this.last = node;
        }
        this.size++;
        return node;
    };
    LinkedList.prototype.addManyAfter = function (values, previousValue, compareFn) {
        if (compareFn === void 0) { compareFn = compare; }
        var previous = this.find(function (node) { return compareFn(node.value, previousValue); });
        return previous ? this.attachMany(values, previous, previous.next) : this.addManyTail(values);
    };
    LinkedList.prototype.addManyBefore = function (values, nextValue, compareFn) {
        if (compareFn === void 0) { compareFn = compare; }
        var next = this.find(function (node) { return compareFn(node.value, nextValue); });
        return next ? this.attachMany(values, next.previous, next) : this.addManyHead(values);
    };
    LinkedList.prototype.addManyByIndex = function (values, position) {
        if (position < 0)
            position += this.size;
        if (position <= 0)
            return this.addManyHead(values);
        if (position >= this.size)
            return this.addManyTail(values);
        var next = this.get(position);
        return this.attachMany(values, next.previous, next);
    };
    LinkedList.prototype.addManyHead = function (values) {
        var _this = this;
        return values.reduceRight(function (nodes, value) {
            nodes.unshift(_this.addHead(value));
            return nodes;
        }, []);
    };
    LinkedList.prototype.addManyTail = function (values) {
        var _this = this;
        return values.map(function (value) { return _this.addTail(value); });
    };
    LinkedList.prototype.drop = function () {
        var _this = this;
        return {
            byIndex: function (position) { return _this.dropByIndex(position); },
            byValue: function () {
                var params = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    params[_i] = arguments[_i];
                }
                return _this.dropByValue.apply(_this, params);
            },
            byValueAll: function () {
                var params = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    params[_i] = arguments[_i];
                }
                return _this.dropByValueAll.apply(_this, params);
            },
            head: function () { return _this.dropHead(); },
            tail: function () { return _this.dropTail(); },
        };
    };
    LinkedList.prototype.dropMany = function (count) {
        var _this = this;
        return {
            byIndex: function (position) { return _this.dropManyByIndex(count, position); },
            head: function () { return _this.dropManyHead(count); },
            tail: function () { return _this.dropManyTail(count); },
        };
    };
    LinkedList.prototype.dropByIndex = function (position) {
        if (position < 0)
            position += this.size;
        var current = this.get(position);
        return current ? this.detach(current) : undefined;
    };
    LinkedList.prototype.dropByValue = function (value, compareFn) {
        if (compareFn === void 0) { compareFn = compare; }
        var position = this.findIndex(function (node) { return compareFn(node.value, value); });
        return position < 0 ? undefined : this.dropByIndex(position);
    };
    LinkedList.prototype.dropByValueAll = function (value, compareFn) {
        if (compareFn === void 0) { compareFn = compare; }
        var dropped = [];
        for (var current = this.first, position = 0; current; position++, current = current.next) {
            if (compareFn(current.value, value)) {
                dropped.push(this.dropByIndex(position - dropped.length));
            }
        }
        return dropped;
    };
    LinkedList.prototype.dropHead = function () {
        var head = this.first;
        if (head) {
            this.first = head.next;
            if (this.first)
                this.first.previous = undefined;
            else
                this.last = undefined;
            this.size--;
            return head;
        }
        return undefined;
    };
    LinkedList.prototype.dropTail = function () {
        var tail = this.last;
        if (tail) {
            this.last = tail.previous;
            if (this.last)
                this.last.next = undefined;
            else
                this.first = undefined;
            this.size--;
            return tail;
        }
        return undefined;
    };
    LinkedList.prototype.dropManyByIndex = function (count, position) {
        if (count <= 0)
            return [];
        if (position < 0)
            position = Math.max(position + this.size, 0);
        else if (position >= this.size)
            return [];
        count = Math.min(count, this.size - position);
        var dropped = [];
        while (count--) {
            var current = this.get(position);
            dropped.push(this.detach(current));
        }
        return dropped;
    };
    LinkedList.prototype.dropManyHead = function (count) {
        if (count <= 0)
            return [];
        count = Math.min(count, this.size);
        var dropped = [];
        while (count--)
            dropped.unshift(this.dropHead());
        return dropped;
    };
    LinkedList.prototype.dropManyTail = function (count) {
        if (count <= 0)
            return [];
        count = Math.min(count, this.size);
        var dropped = [];
        while (count--)
            dropped.push(this.dropTail());
        return dropped;
    };
    LinkedList.prototype.find = function (predicate) {
        for (var current = this.first, position = 0; current; position++, current = current.next) {
            if (predicate(current, position, this))
                return current;
        }
        return undefined;
    };
    LinkedList.prototype.findIndex = function (predicate) {
        for (var current = this.first, position = 0; current; position++, current = current.next) {
            if (predicate(current, position, this))
                return position;
        }
        return -1;
    };
    LinkedList.prototype.forEach = function (iteratorFn) {
        for (var node = this.first, position = 0; node; position++, node = node.next) {
            iteratorFn(node, position, this);
        }
    };
    LinkedList.prototype.get = function (position) {
        return this.find(function (_, index) { return position === index; });
    };
    LinkedList.prototype.indexOf = function (value, compareFn) {
        if (compareFn === void 0) { compareFn = compare; }
        return this.findIndex(function (node) { return compareFn(node.value, value); });
    };
    LinkedList.prototype.toArray = function () {
        var array = new Array(this.size);
        this.forEach(function (node, index) { return (array[index] = node.value); });
        return array;
    };
    LinkedList.prototype.toNodeArray = function () {
        var array = new Array(this.size);
        this.forEach(function (node, index) { return (array[index] = node); });
        return array;
    };
    LinkedList.prototype.toString = function (mapperFn) {
        if (mapperFn === void 0) { mapperFn = JSON.stringify; }
        return this.toArray()
            .map(function (value) { return mapperFn(value); })
            .join(' <-> ');
    };
    // Cannot use Generator type because of ng-packagr
    LinkedList.prototype[Symbol.iterator] = function () {
        var node, position;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    node = this.first, position = 0;
                    _a.label = 1;
                case 1:
                    if (!node) return [3 /*break*/, 4];
                    return [4 /*yield*/, node.value];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3:
                    position++, node = node.next;
                    return [3 /*break*/, 1];
                case 4: return [2 /*return*/];
            }
        });
    };
    return LinkedList;
}());

/*
 * Public API Surface of utils
 */

/**
 * Generated bundle index. Do not edit.
 */

export { LinkedList, ListNode };
//# sourceMappingURL=abp-utils.js.map
