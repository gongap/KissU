import { CommonModule } from '@angular/common';
import { Injectable, Component, ElementRef, Input, Output, EventEmitter, ChangeDetectionStrategy, ViewEncapsulation, defineInjectable, NgModule } from '@angular/core';

class Timer {
    constructor() {
        this.fns = [];
        this.commands = [];
        this.ing = false;
    }
    start() {
        if (this.ing === true)
            return;
        this.ing = true;
        this.nextTime = +new Date();
        this.process();
    }
    process() {
        while (this.commands.length) {
            this.commands.shift()();
        }
        let diff = +new Date() - this.nextTime;
        const count = 1 + Math.floor(diff / 100);
        diff = 100 - diff % 100;
        this.nextTime += 100 * count;
        let frequency, step, i, len;
        for (i = 0, len = this.fns.length; i < len; i += 2) {
            frequency = this.fns[i + 1];
            // 100/s
            if (0 === frequency) {
                this.fns[i](count);
                // 1000/s
            }
            else {
                // 先把末位至0，再每次加2
                frequency += 2 * count - 1;
                step = Math.floor(frequency / 20);
                if (step > 0) {
                    this.fns[i](step);
                }
                // 把末位还原成1
                this.fns[i + 1] = frequency % 20 + 1;
            }
        }
        if (this.ing) {
            setTimeout(() => this.process(), diff);
        }
    }
    add(fn, frequency) {
        this.commands.push(() => {
            this.fns.push(fn);
            this.fns.push(frequency === 1000 ? 1 : 0);
            this.ing = true;
        });
    }
    remove(fn) {
        this.commands.push(() => {
            const i = this.fns.indexOf(fn);
            if (i !== -1) {
                this.fns.splice(i, 2);
            }
            this.ing = this.fns.length > 0;
        });
    }
}
Timer.decorators = [
    { type: Injectable }
];

class CountdownConfig {
    constructor() {
        this.demand = false;
        this.leftTime = 0;
        this.template = '$!h!时$!m!分$!s!秒';
        this.effect = 'normal';
        this.varRegular = /\$\!([\-\w]+)\!/g;
        this.clock = ['d', 100, 2, 'h', 24, 2, 'm', 60, 2, 's', 60, 2, 'u', 10, 1];
    }
}
CountdownConfig.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
CountdownConfig.ngInjectableDef = defineInjectable({ factory: function CountdownConfig_Factory() { return new CountdownConfig(); }, token: CountdownConfig, providedIn: "root" });

class CountdownComponent {
    constructor(el, timer, cog) {
        this.el = el;
        this.timer = timer;
        this.cog = cog;
        this.frequency = 1000;
        this._notify = {};
        this.hands = [];
        this.left = 0;
        this.paused = false;
        /** 两种情况会触发：时间终止或调用 `stop()` */
        this.stoped = false;
        this.start = new EventEmitter();
        this.finished = new EventEmitter();
        this.notify = new EventEmitter();
        this.event = new EventEmitter();
    }
    /** 开始，当 `demand: false` 时触发 */
    begin() {
        this.paused = false;
        this.start.emit();
        this.callEvent('start');
    }
    /** 重新开始 */
    restart() {
        if (!this.stoped)
            this.destroy();
        this.init();
        this.callEvent('restart');
    }
    /** 停止 */
    stop() {
        if (this.stoped)
            return;
        this.stoped = true;
        this.destroy();
        this.callEvent('stop');
    }
    /** 暂停（限未终止有效） */
    pause() {
        if (this.stoped || this.paused)
            return;
        this.paused = true;
        this.callEvent('pause');
    }
    /** 恢复 */
    resume() {
        if (this.stoped || !this.paused)
            return;
        this.paused = false;
        this.callEvent('resume');
    }
    callEvent(action) {
        this.event.emit({ action, left: this.left });
    }
    init() {
        const me = this;
        me.config = Object.assign({}, new CountdownConfig(), me.cog, me.config);
        const el = me.el.nativeElement;
        me.paused = me.config.demand;
        me.stoped = false;
        // 分析markup
        const tmpl = el.innerHTML || me.config.template;
        me.config.varRegular.lastIndex = 0;
        el.innerHTML = tmpl.replace(me.config.varRegular, (str, type) => {
            // 时钟频率校正.
            if (type === 'u' || type === 's-ext')
                me.frequency = 100;
            // 生成hand的markup
            let content = '';
            if (type === 's-ext') {
                me.hands.push({ type: 's' });
                me.hands.push({ type: 'u' });
                content =
                    me.html('', 's', 'handlet') +
                        me.html('.', '', 'digital') +
                        me.html('', 'u', 'handlet');
            }
            else {
                me.hands.push({ type: type });
            }
            return me.html(content, type, 'hand');
        });
        const clock = me.config.clock;
        me.hands.forEach((hand) => {
            const type = hand.type;
            let base = 100, i;
            hand.node = el.querySelector(`.hand-${type}`);
            // radix, bits 初始化
            for (i = clock.length - 3; i > -1; i -= 3) {
                if (type === clock[i]) {
                    break;
                }
                base *= clock[i + 1];
            }
            hand.base = base;
            hand.radix = clock[i + 1];
            hand.bits = clock[i + 2];
        });
        me.getLeft();
        me.reflow(0, true);
        // bind reflow to me
        const _reflow = me.reflow;
        me.reflow = (count = 0) => {
            return _reflow.apply(me, [count]);
        };
        // 构建 notify
        if (me.config.notify) {
            me.config.notify.forEach((time) => {
                if (time < 1)
                    throw new Error(`the notify config must be a positive integer.`);
                time = time * 1000;
                time = time - (time % me.frequency);
                me._notify[time] = true;
            });
        }
        me.timer.add(me.reflow, me.frequency);
        // show
        el.style.display = 'inline';
        this.timer.start();
        return me;
    }
    destroy() {
        this.timer.remove(this.reflow);
        return this;
    }
    /**
     * 更新时钟
     */
    reflow(count = 0, force = false) {
        const me = this;
        if (!force && (me.paused || me.stoped))
            return;
        me.left = me.left - me.frequency * count;
        me.hands.forEach((hand) => {
            hand.lastValue = hand.value;
            hand.value = Math.floor(me.left / hand.base) % hand.radix;
        });
        me.repaint();
        if (me._notify[me.left]) {
            me.notify.emit(me.left);
            me.callEvent('notify');
        }
        if (me.left < 1) {
            me.finished.emit(0);
            me.stoped = true;
            me.callEvent('finished');
            me.destroy();
        }
    }
    /**
     * 重绘时钟
     */
    repaint() {
        const me = this;
        if (me.config.repaint) {
            me.config.repaint.apply(me);
            return;
        }
        let content;
        me.hands.forEach((hand) => {
            if (hand.lastValue !== hand.value) {
                content = '';
                me.toDigitals(hand.value, hand.bits).forEach((digital) => {
                    content += me.html(digital.toString(), '', 'digital');
                });
                hand.node.innerHTML = content;
            }
        });
    }
    /**
     * 获取倒计时剩余帧数
     */
    getLeft() {
        const me = this;
        let left = me.config.leftTime * 1000;
        const end = me.config.stopTime;
        if (!left && end)
            left = end - new Date().getTime();
        me.left = left - (left % me.frequency);
    }
    /**
     * 生成需要的html代码，辅助工具
     */
    html(con, className, type) {
        switch (type) {
            case 'hand':
            case 'handlet':
                className = type + ' hand-' + className;
                break;
            case 'digital':
                if (con === '.') {
                    className = type + ' ' + type + '-point ' + className;
                }
                else {
                    className = type + ' ' + type + '-' + con + ' ' + className;
                }
                break;
        }
        return '<span class="' + className + '">' + con + '</span>';
    }
    /**
     * 把值转换为独立的数字形式
     */
    toDigitals(value, bits) {
        value = value < 0 ? 0 : value;
        const digitals = [];
        // 把时、分、秒等换算成数字.
        while (bits--) {
            digitals[bits] = value % 10;
            value = Math.floor(value / 10);
        }
        return digitals;
    }
    ngOnInit() {
        this.init();
        if (!this.config.demand)
            this.begin();
    }
    ngOnDestroy() {
        this.destroy();
    }
    ngOnChanges(changes) {
        if (!changes.config.firstChange) {
            this.restart();
        }
    }
}
CountdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'countdown',
                template: `
    <ng-content></ng-content>
  `,
                host: { '[class.count-down]': 'true' },
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
      countdown {
        display: none;
      }
    `]
            }] }
];
/** @nocollapse */
CountdownComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Timer },
    { type: CountdownConfig }
];
CountdownComponent.propDecorators = {
    config: [{ type: Input }],
    start: [{ type: Output }],
    finished: [{ type: Output }],
    notify: [{ type: Output }],
    event: [{ type: Output }]
};

class CountdownModule {
}
CountdownModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                providers: [Timer],
                declarations: [CountdownComponent],
                exports: [CountdownComponent]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { CountdownConfig as ɵa, CountdownComponent, Timer, CountdownModule };

//# sourceMappingURL=ngx-countdown.js.map